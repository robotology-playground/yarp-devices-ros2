/*
 * SPDX-FileCopyrightText: 2023 Istituto Italiano di Tecnologia (IIT)
 * SPDX-License-Identifier: BSD-3-Clause
 */

#ifndef YARP_DEV_GENERICSENSORS_NWS_ROS2_H
#define YARP_DEV_GENERICSENSORS_NWS_ROS2_H

#include <yarp/os/PeriodicThread.h>
#include <yarp/dev/DeviceDriver.h>
#include <yarp/dev/IMultipleWrapper.h>
#include <yarp/dev/MultipleAnalogSensorsInterfaces.h>
#include <yarp/os/Log.h>
#include <yarp/os/LogComponent.h>
#include <yarp/os/LogStream.h>

#include <rclcpp/rclcpp.hpp>
#include <Ros2Utils.h>


// The log component is defined in each device, with a specialized name
YARP_DECLARE_LOG_COMPONENT(GENERICSENSOR_NWS_ROS2)


/**
 * @ingroup dev_impl_wrapper
 *
 * \brief This abstract template needs to be specialized in a ROS Publisher, for a specific ROS mesagge/sensor type.
 *
 * | YARP device name |
 * |:-----------------:|
 * | `GenericSensor_nws_ros2` |
 *
 * The parameters accepted by this device are:
 * | Parameter name | SubParameter   | Type    | Units          | Default Value    | Required                    | Description                                                       | Notes |
 * |:--------------:|:--------------:|:-------:|:--------------:|:----------------:|:--------------------------: |:-----------------------------------------------------------------:|:-----:|
 * | topic_name     |      -         | string  | -              |   -              | Yes                         | The name of the ROS topic opened by this device.                  | MUST start with a '/' character |
 * | node_name      |      -         | string  | -              |   -              | Yes                         | The name of the ROS node opened by this device                    | Autogenerated by default |
 * | period         |      -         | double  | s              |   -              | Yes                         | Refresh period of the broadcasted values in seconds               |  |
 */

template <class ROS_MSG>
class GenericSensor_nws_ros2 :
        public yarp::os::PeriodicThread,
        public yarp::dev::DeviceDriver,
        public yarp::dev::IMultipleWrapper
{
protected:
    double            m_periodInS{0.01};
    std::string       m_publisherName;
    std::string       m_rosNodeName;
    rclcpp::Node::SharedPtr m_node=nullptr;
    typename rclcpp::Publisher<ROS_MSG>::SharedPtr m_publisher=nullptr;
    yarp::dev::PolyDriver* m_poly=nullptr;
    double                 m_timestamp;
    std::string            m_framename;
    const size_t           m_sens_index = 0;
    yarp::dev::PolyDriver  m_subdevicedriver;

public:
    GenericSensor_nws_ros2();
    virtual ~GenericSensor_nws_ros2();

    /* DevideDriver methods */
    bool open(yarp::os::Searchable &params) override;
    bool close() override;

    /* IMultipleWrapper methods */
    bool attachAll(const yarp::dev::PolyDriverList &p) override;
    bool detachAll() override;

    /* PeriodicRateThread methods */
    void threadRelease() override;
    void run() override;

protected:
    virtual bool viewInterfaces() = 0;
};

template <class ROS_MSG>
GenericSensor_nws_ros2<ROS_MSG>::GenericSensor_nws_ros2() :
    PeriodicThread(0.02)
{
    m_timestamp=0;
}

template <class ROS_MSG>
GenericSensor_nws_ros2<ROS_MSG>::~GenericSensor_nws_ros2() = default;

template <class ROS_MSG>
bool GenericSensor_nws_ros2<ROS_MSG>::open(yarp::os::Searchable & config)
{
    if (!config.check("topic_name")) {
        yCError(GENERICSENSOR_NWS_ROS2, "Missing `topic_name` parameter, exiting.");
        return false;
    }

    if (!config.check("period")) {
        yCError(GENERICSENSOR_NWS_ROS2, "Missing `period` parameter, exiting.");
        return false;
    }

    if (config.find("period").isFloat32()==false && config.find("period").isFloat64()==false) {
        yCError(GENERICSENSOR_NWS_ROS2, "`period` parameter is present but it is not a float, exiting.");
        return false;
    }

    m_periodInS = config.find("period").asFloat64();

    if (m_periodInS <= 0) {
        yCError(GENERICSENSOR_NWS_ROS2, "`period` parameter is present (%f) but it is not a positive value, exiting.", m_periodInS);
        return false;
    }

    if (!config.check("node_name"))
    {
        yCError(GENERICSENSOR_NWS_ROS2) << "Missing node_name parameter";
        return false;
    }

    m_rosNodeName = config.find("node_name").asString();
    if (m_rosNodeName.c_str()[0] == '/') {
        yCError(GENERICSENSOR_NWS_ROS2) << "node name cannot begin with /";
        return false;
    }

    m_publisherName = config.find("topic_name").asString();

    if (m_publisherName.c_str()[0] != '/') {
        yCError(GENERICSENSOR_NWS_ROS2) << "Missing '/' in topic_name parameter";
        return false;
    }

    m_node = NodeCreator::createNode(m_rosNodeName); // add a ROS node
    m_publisher = m_node->create_publisher<ROS_MSG>(m_publisherName,rclcpp::QoS(10));

    if (m_node == nullptr) {
        yCError(GENERICSENSOR_NWS_ROS2) << "Opening " << m_rosNodeName << " Node, check your yarp-ROS network configuration\n";
        return false;
    }

    if (m_publisher == nullptr) {
        yCError(GENERICSENSOR_NWS_ROS2) << "Opening " << m_publisherName << " Topic, check your yarp-ROS network configuration\n";
        return false;
    }

    yCInfo(GENERICSENSOR_NWS_ROS2) << "Running, waiting for attach...";

    return true;
}

template <class ROS_MSG>
bool GenericSensor_nws_ros2<ROS_MSG>::close()
{
    return this->detachAll();
}

template <class ROS_MSG>
bool GenericSensor_nws_ros2<ROS_MSG>::attachAll(const yarp::dev::PolyDriverList & p)
{
    // Attach the device
    if (p.size() > 1)
    {
        yCError(GENERICSENSOR_NWS_ROS2, "This device only supports exposing a "
            "single MultipleAnalogSensors device on YARP ports, but %d devices have been passed in attachAll.",
            p.size());
        yCError(GENERICSENSOR_NWS_ROS2, "Please use the multipleanalogsensorsremapper device to combine several device in a new device.");
        detachAll();
        return false;
    }

    if (p.size() == 0)
    {
        yCError(GENERICSENSOR_NWS_ROS2, "No device passed to attachAll, please pass a device to expose on YARP ports.");
        return false;
    }

    m_poly = p[0]->poly;

    if (!m_poly)
    {
        yCError(GENERICSENSOR_NWS_ROS2, "Null pointer passed to attachAll.");
        return false;
    }

    // View all the interfaces
    bool ok = viewInterfaces();
    if (!ok)
    {
        yCError(GENERICSENSOR_NWS_ROS2, "viewInterfaces failed.");
        return false;
    }

    // Set rate period
    ok &= this->setPeriod(m_periodInS);
    ok &= this->start();
    if (!ok)
    {
        yCError(GENERICSENSOR_NWS_ROS2, "thread->start() failed.");
        return false;
    }

    return ok;
}

template <class ROS_MSG>
bool GenericSensor_nws_ros2<ROS_MSG>::detachAll()
{
    // Stop the thread on detach
    if (this->isRunning()) {
        this->stop();
    }
    return true;
}

template <class ROS_MSG>
void GenericSensor_nws_ros2<ROS_MSG>::run()
{
}

template <class ROS_MSG>
void GenericSensor_nws_ros2<ROS_MSG>::threadRelease()
{
    return;
}

#endif
